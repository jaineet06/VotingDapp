#pragma version 11
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 0 1 2 8
    bytecblock "voted" 0x151f7c75 "active" "endTime" "v1" "v2" "v3" "total" "question" "opt1" "opt2" "opt3" "creator" "choice"
    // smart_contracts/voting/contract.algo.ts:7
    // export class VotingContract extends Contract {
    txn NumAppArgs
    bz main___algots__.defaultCreate@19
    pushbytes 0x01a3a3ff // method "optInToApplication()void"
    txna ApplicationArgs 0
    match main_optInToApplication_route@3
    txn OnCompletion
    !
    assert // OnCompletion must be NoOp
    txn ApplicationID
    assert
    pushbytess 0xa9dc6e3b 0x31d5c300 0x54d4f9e9 0xfba8c52c 0x78fe61da 0x99f9c1b3 0x13550a91 0x1d048a5b 0x7ec9c8a9 0x82a272d7 // method "createPoll(byte[],byte[],byte[],byte[],uint64)void", method "vote(uint64)void", method "getResults()uint64[]", method "getPollQuestion()byte[]", method "getOption(uint64)byte[]", method "checkPollActive()uint64", method "getRemainingTime()uint64", method "endPoll()void", method "checkHasVoted()uint64", method "getMyVote()uint64"
    txna ApplicationArgs 0
    match createPoll vote getResults getPollQuestion getOption checkPollActive getRemainingTime endPoll checkHasVoted getMyVote
    err

main_optInToApplication_route@3:
    // smart_contracts/voting/contract.algo.ts:33
    // optInToApplication(): void {
    txn OnCompletion
    intc_1 // OptIn
    ==
    txn ApplicationID
    &&
    assert // OnCompletion must be OptIn && can only call when not creating
    intc_1 // 1
    return

main___algots__.defaultCreate@19:
    // smart_contracts/voting/contract.algo.ts:7
    // export class VotingContract extends Contract {
    txn OnCompletion
    !
    txn ApplicationID
    !
    &&
    assert // OnCompletion must be NoOp && can only call when creating
    intc_1 // 1
    return


// smart_contracts/voting/contract.algo.ts::VotingContract.createPoll[routing]() -> void:
createPoll:
    // smart_contracts/voting/contract.algo.ts:41-47
    // createPoll(
    //   question: bytes,
    //   opt1: bytes,
    //   opt2: bytes,
    //   opt3: bytes,
    //   durationSeconds: uint64
    // ): void {
    txna ApplicationArgs 1
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    extract 2 0
    txna ApplicationArgs 2
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    extract 2 0
    txna ApplicationArgs 3
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    extract 2 0
    txna ApplicationArgs 4
    dup
    intc_0 // 0
    extract_uint16 // on error: invalid array length header
    intc_2 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    extract 2 0
    txna ApplicationArgs 5
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    // smart_contracts/voting/contract.algo.ts:49
    // if (this.isPollActive.hasValue) {
    intc_0 // 0
    // smart_contracts/voting/contract.algo.ts:23
    // isPollActive = GlobalState<uint64>({ key: 'active' })
    bytec_2 // "active"
    // smart_contracts/voting/contract.algo.ts:49
    // if (this.isPollActive.hasValue) {
    app_global_get_ex
    bury 1
    bz createPoll_after_if_else@3
    // smart_contracts/voting/contract.algo.ts:50
    // assert(this.isPollActive.value === Uint64(0), 'Poll already active')
    intc_0 // 0
    // smart_contracts/voting/contract.algo.ts:23
    // isPollActive = GlobalState<uint64>({ key: 'active' })
    bytec_2 // "active"
    // smart_contracts/voting/contract.algo.ts:50
    // assert(this.isPollActive.value === Uint64(0), 'Poll already active')
    app_global_get_ex
    assert // check GlobalState exists
    !
    assert // Poll already active

createPoll_after_if_else@3:
    // smart_contracts/voting/contract.algo.ts:9
    // pollQuestion = GlobalState<bytes>({ key: 'question' })
    bytec 8 // "question"
    // smart_contracts/voting/contract.algo.ts:53
    // this.pollQuestion.value = question
    dig 5
    app_global_put
    // smart_contracts/voting/contract.algo.ts:10
    // option1 = GlobalState<bytes>({ key: 'opt1' })
    bytec 9 // "opt1"
    // smart_contracts/voting/contract.algo.ts:54
    // this.option1.value = opt1
    dig 4
    app_global_put
    // smart_contracts/voting/contract.algo.ts:11
    // option2 = GlobalState<bytes>({ key: 'opt2' })
    bytec 10 // "opt2"
    // smart_contracts/voting/contract.algo.ts:55
    // this.option2.value = opt2
    dig 3
    app_global_put
    // smart_contracts/voting/contract.algo.ts:12
    // option3 = GlobalState<bytes>({ key: 'opt3' })
    bytec 11 // "opt3"
    // smart_contracts/voting/contract.algo.ts:56
    // this.option3.value = opt3
    dig 2
    app_global_put
    // smart_contracts/voting/contract.algo.ts:15
    // votes1 = GlobalState<uint64>({ key: 'v1' })
    bytec 4 // "v1"
    // smart_contracts/voting/contract.algo.ts:58
    // this.votes1.value = Uint64(0)
    intc_0 // 0
    app_global_put
    // smart_contracts/voting/contract.algo.ts:16
    // votes2 = GlobalState<uint64>({ key: 'v2' })
    bytec 5 // "v2"
    // smart_contracts/voting/contract.algo.ts:59
    // this.votes2.value = Uint64(0)
    intc_0 // 0
    app_global_put
    // smart_contracts/voting/contract.algo.ts:17
    // votes3 = GlobalState<uint64>({ key: 'v3' })
    bytec 6 // "v3"
    // smart_contracts/voting/contract.algo.ts:60
    // this.votes3.value = Uint64(0)
    intc_0 // 0
    app_global_put
    // smart_contracts/voting/contract.algo.ts:22
    // totalVotes = GlobalState<uint64>({ key: 'total' })
    bytec 7 // "total"
    // smart_contracts/voting/contract.algo.ts:61
    // this.totalVotes.value = Uint64(0)
    intc_0 // 0
    app_global_put
    // smart_contracts/voting/contract.algo.ts:63
    // this.pollEndTime.value = Global.latestTimestamp + durationSeconds
    global LatestTimestamp
    dig 1
    +
    // smart_contracts/voting/contract.algo.ts:20
    // pollEndTime = GlobalState<uint64>({ key: 'endTime' })
    bytec_3 // "endTime"
    // smart_contracts/voting/contract.algo.ts:63
    // this.pollEndTime.value = Global.latestTimestamp + durationSeconds
    swap
    app_global_put
    // smart_contracts/voting/contract.algo.ts:21
    // pollCreator = GlobalState<bytes>({ key: 'creator' })
    bytec 12 // "creator"
    // smart_contracts/voting/contract.algo.ts:64
    // this.pollCreator.value = Txn.sender.bytes
    txn Sender
    app_global_put
    // smart_contracts/voting/contract.algo.ts:23
    // isPollActive = GlobalState<uint64>({ key: 'active' })
    bytec_2 // "active"
    // smart_contracts/voting/contract.algo.ts:65
    // this.isPollActive.value = Uint64(1)
    intc_1 // 1
    app_global_put
    // smart_contracts/voting/contract.algo.ts:41-47
    // createPoll(
    //   question: bytes,
    //   opt1: bytes,
    //   opt2: bytes,
    //   opt3: bytes,
    //   durationSeconds: uint64
    // ): void {
    intc_1 // 1
    return


// smart_contracts/voting/contract.algo.ts::VotingContract.vote[routing]() -> void:
vote:
    // smart_contracts/voting/contract.algo.ts:71
    // vote(optionIndex: uint64): void {
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    dup
    // smart_contracts/voting/contract.algo.ts:72
    // assert(this.isPollActive.value === Uint64(1), 'Poll is not active')
    intc_0 // 0
    // smart_contracts/voting/contract.algo.ts:23
    // isPollActive = GlobalState<uint64>({ key: 'active' })
    bytec_2 // "active"
    // smart_contracts/voting/contract.algo.ts:72
    // assert(this.isPollActive.value === Uint64(1), 'Poll is not active')
    app_global_get_ex
    assert // check GlobalState exists
    intc_1 // 1
    ==
    assert // Poll is not active
    // smart_contracts/voting/contract.algo.ts:73
    // assert(Global.latestTimestamp < this.pollEndTime.value, 'Poll has ended')
    global LatestTimestamp
    intc_0 // 0
    // smart_contracts/voting/contract.algo.ts:20
    // pollEndTime = GlobalState<uint64>({ key: 'endTime' })
    bytec_3 // "endTime"
    // smart_contracts/voting/contract.algo.ts:73
    // assert(Global.latestTimestamp < this.pollEndTime.value, 'Poll has ended')
    app_global_get_ex
    assert // check GlobalState exists
    <
    assert // Poll has ended
    // smart_contracts/voting/contract.algo.ts:74
    // assert(optionIndex >= Uint64(1) && optionIndex <= Uint64(3), 'Invalid option')
    bz vote_bool_false@4
    dup
    pushint 3 // 3
    <=
    bz vote_bool_false@4
    intc_1 // 1

vote_bool_merge@5:
    // smart_contracts/voting/contract.algo.ts:74
    // assert(optionIndex >= Uint64(1) && optionIndex <= Uint64(3), 'Invalid option')
    assert // Invalid option
    // smart_contracts/voting/contract.algo.ts:77
    // if (this.hasVoted(Txn.sender).hasValue) {
    txn Sender
    intc_0 // 0
    // smart_contracts/voting/contract.algo.ts:26
    // hasVoted = LocalState<uint64>({ key: 'voted' })
    bytec_0 // "voted"
    // smart_contracts/voting/contract.algo.ts:77
    // if (this.hasVoted(Txn.sender).hasValue) {
    app_local_get_ex
    bury 1
    bz vote_after_if_else@7
    // smart_contracts/voting/contract.algo.ts:78
    // assert(this.hasVoted(Txn.sender).value === Uint64(0), 'Already voted')
    txn Sender
    intc_0 // 0
    // smart_contracts/voting/contract.algo.ts:26
    // hasVoted = LocalState<uint64>({ key: 'voted' })
    bytec_0 // "voted"
    // smart_contracts/voting/contract.algo.ts:78
    // assert(this.hasVoted(Txn.sender).value === Uint64(0), 'Already voted')
    app_local_get_ex
    assert // check LocalState exists
    !
    assert // Already voted

vote_after_if_else@7:
    // smart_contracts/voting/contract.algo.ts:81
    // if (optionIndex === Uint64(1)) {
    dup
    intc_1 // 1
    ==
    bz vote_else_body@9
    // smart_contracts/voting/contract.algo.ts:82
    // this.votes1.value = this.votes1.value + Uint64(1)
    intc_0 // 0
    // smart_contracts/voting/contract.algo.ts:15
    // votes1 = GlobalState<uint64>({ key: 'v1' })
    bytec 4 // "v1"
    // smart_contracts/voting/contract.algo.ts:82
    // this.votes1.value = this.votes1.value + Uint64(1)
    app_global_get_ex
    assert // check GlobalState exists
    intc_1 // 1
    +
    // smart_contracts/voting/contract.algo.ts:15
    // votes1 = GlobalState<uint64>({ key: 'v1' })
    bytec 4 // "v1"
    // smart_contracts/voting/contract.algo.ts:82
    // this.votes1.value = this.votes1.value + Uint64(1)
    swap
    app_global_put

vote_after_if_else@15:
    // smart_contracts/voting/contract.algo.ts:89
    // this.totalVotes.value = this.totalVotes.value + Uint64(1)
    intc_0 // 0
    // smart_contracts/voting/contract.algo.ts:22
    // totalVotes = GlobalState<uint64>({ key: 'total' })
    bytec 7 // "total"
    // smart_contracts/voting/contract.algo.ts:89
    // this.totalVotes.value = this.totalVotes.value + Uint64(1)
    app_global_get_ex
    assert // check GlobalState exists
    intc_1 // 1
    +
    // smart_contracts/voting/contract.algo.ts:22
    // totalVotes = GlobalState<uint64>({ key: 'total' })
    bytec 7 // "total"
    // smart_contracts/voting/contract.algo.ts:89
    // this.totalVotes.value = this.totalVotes.value + Uint64(1)
    swap
    app_global_put
    // smart_contracts/voting/contract.algo.ts:90
    // this.hasVoted(Txn.sender).value = Uint64(1)
    txn Sender
    // smart_contracts/voting/contract.algo.ts:26
    // hasVoted = LocalState<uint64>({ key: 'voted' })
    bytec_0 // "voted"
    // smart_contracts/voting/contract.algo.ts:90
    // this.hasVoted(Txn.sender).value = Uint64(1)
    intc_1 // 1
    app_local_put
    // smart_contracts/voting/contract.algo.ts:91
    // this.votedOption(Txn.sender).value = optionIndex
    txn Sender
    // smart_contracts/voting/contract.algo.ts:27
    // votedOption = LocalState<uint64>({ key: 'choice' })
    bytec 13 // "choice"
    // smart_contracts/voting/contract.algo.ts:91
    // this.votedOption(Txn.sender).value = optionIndex
    dig 2
    app_local_put
    // smart_contracts/voting/contract.algo.ts:71
    // vote(optionIndex: uint64): void {
    intc_1 // 1
    return

vote_else_body@9:
    // smart_contracts/voting/contract.algo.ts:83
    // } else if (optionIndex === Uint64(2)) {
    dup
    intc_2 // 2
    ==
    bz vote_else_body@11
    // smart_contracts/voting/contract.algo.ts:84
    // this.votes2.value = this.votes2.value + Uint64(1)
    intc_0 // 0
    // smart_contracts/voting/contract.algo.ts:16
    // votes2 = GlobalState<uint64>({ key: 'v2' })
    bytec 5 // "v2"
    // smart_contracts/voting/contract.algo.ts:84
    // this.votes2.value = this.votes2.value + Uint64(1)
    app_global_get_ex
    assert // check GlobalState exists
    intc_1 // 1
    +
    // smart_contracts/voting/contract.algo.ts:16
    // votes2 = GlobalState<uint64>({ key: 'v2' })
    bytec 5 // "v2"
    // smart_contracts/voting/contract.algo.ts:84
    // this.votes2.value = this.votes2.value + Uint64(1)
    swap
    app_global_put
    b vote_after_if_else@15

vote_else_body@11:
    // smart_contracts/voting/contract.algo.ts:85
    // } else if (optionIndex === Uint64(3)) {
    dup
    pushint 3 // 3
    ==
    bz vote_after_if_else@15
    // smart_contracts/voting/contract.algo.ts:86
    // this.votes3.value = this.votes3.value + Uint64(1)
    intc_0 // 0
    // smart_contracts/voting/contract.algo.ts:17
    // votes3 = GlobalState<uint64>({ key: 'v3' })
    bytec 6 // "v3"
    // smart_contracts/voting/contract.algo.ts:86
    // this.votes3.value = this.votes3.value + Uint64(1)
    app_global_get_ex
    assert // check GlobalState exists
    intc_1 // 1
    +
    // smart_contracts/voting/contract.algo.ts:17
    // votes3 = GlobalState<uint64>({ key: 'v3' })
    bytec 6 // "v3"
    // smart_contracts/voting/contract.algo.ts:86
    // this.votes3.value = this.votes3.value + Uint64(1)
    swap
    app_global_put
    b vote_after_if_else@15

vote_bool_false@4:
    intc_0 // 0
    b vote_bool_merge@5


// smart_contracts/voting/contract.algo.ts::VotingContract.getResults[routing]() -> void:
getResults:
    // smart_contracts/voting/contract.algo.ts:99
    // this.votes1.value,
    intc_0 // 0
    // smart_contracts/voting/contract.algo.ts:15
    // votes1 = GlobalState<uint64>({ key: 'v1' })
    bytec 4 // "v1"
    // smart_contracts/voting/contract.algo.ts:99
    // this.votes1.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/voting/contract.algo.ts:100
    // this.votes2.value,
    intc_0 // 0
    // smart_contracts/voting/contract.algo.ts:16
    // votes2 = GlobalState<uint64>({ key: 'v2' })
    bytec 5 // "v2"
    // smart_contracts/voting/contract.algo.ts:100
    // this.votes2.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/voting/contract.algo.ts:101
    // this.votes3.value,
    intc_0 // 0
    // smart_contracts/voting/contract.algo.ts:17
    // votes3 = GlobalState<uint64>({ key: 'v3' })
    bytec 6 // "v3"
    // smart_contracts/voting/contract.algo.ts:101
    // this.votes3.value,
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/voting/contract.algo.ts:102
    // this.totalVotes.value
    intc_0 // 0
    // smart_contracts/voting/contract.algo.ts:22
    // totalVotes = GlobalState<uint64>({ key: 'total' })
    bytec 7 // "total"
    // smart_contracts/voting/contract.algo.ts:102
    // this.totalVotes.value
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/voting/contract.algo.ts:98-103
    // return [
    //   this.votes1.value,
    //   this.votes2.value,
    //   this.votes3.value,
    //   this.totalVotes.value
    // ]
    uncover 3
    itob
    pushbytes 0x0004
    swap
    concat
    uncover 3
    itob
    concat
    uncover 2
    itob
    concat
    swap
    itob
    concat
    // smart_contracts/voting/contract.algo.ts:97
    // getResults(): uint64[] {
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/voting/contract.algo.ts::VotingContract.getPollQuestion[routing]() -> void:
getPollQuestion:
    // smart_contracts/voting/contract.algo.ts:110
    // return this.pollQuestion.value
    intc_0 // 0
    // smart_contracts/voting/contract.algo.ts:9
    // pollQuestion = GlobalState<bytes>({ key: 'question' })
    bytec 8 // "question"
    // smart_contracts/voting/contract.algo.ts:110
    // return this.pollQuestion.value
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/voting/contract.algo.ts:109
    // getPollQuestion(): bytes {
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return


// smart_contracts/voting/contract.algo.ts::VotingContract.getOption[routing]() -> void:
getOption:
    // smart_contracts/voting/contract.algo.ts:116
    // getOption(index: uint64): bytes {
    txna ApplicationArgs 1
    dup
    len
    intc_3 // 8
    ==
    assert // invalid number of bytes for arc4.uint64
    btoi
    dup
    // smart_contracts/voting/contract.algo.ts:117
    // if (index === Uint64(1)) return this.option1.value
    intc_1 // 1
    ==
    bz getOption_after_if_else@3
    intc_0 // 0
    // smart_contracts/voting/contract.algo.ts:10
    // option1 = GlobalState<bytes>({ key: 'opt1' })
    bytec 9 // "opt1"
    // smart_contracts/voting/contract.algo.ts:117
    // if (index === Uint64(1)) return this.option1.value
    app_global_get_ex
    assert // check GlobalState exists

getOption_after_inlined_smart_contracts/voting/contract.algo.ts::VotingContract.getOption@6:
    // smart_contracts/voting/contract.algo.ts:116
    // getOption(index: uint64): bytes {
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

getOption_after_if_else@3:
    // smart_contracts/voting/contract.algo.ts:118
    // if (index === Uint64(2)) return this.option2.value
    dup
    intc_2 // 2
    ==
    bz getOption_after_if_else@5
    intc_0 // 0
    // smart_contracts/voting/contract.algo.ts:11
    // option2 = GlobalState<bytes>({ key: 'opt2' })
    bytec 10 // "opt2"
    // smart_contracts/voting/contract.algo.ts:118
    // if (index === Uint64(2)) return this.option2.value
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/voting/contract.algo.ts:116
    // getOption(index: uint64): bytes {
    b getOption_after_inlined_smart_contracts/voting/contract.algo.ts::VotingContract.getOption@6

getOption_after_if_else@5:
    // smart_contracts/voting/contract.algo.ts:119
    // return this.option3.value
    intc_0 // 0
    // smart_contracts/voting/contract.algo.ts:12
    // option3 = GlobalState<bytes>({ key: 'opt3' })
    bytec 11 // "opt3"
    // smart_contracts/voting/contract.algo.ts:119
    // return this.option3.value
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/voting/contract.algo.ts:116
    // getOption(index: uint64): bytes {
    b getOption_after_inlined_smart_contracts/voting/contract.algo.ts::VotingContract.getOption@6


// smart_contracts/voting/contract.algo.ts::VotingContract.checkPollActive[routing]() -> void:
checkPollActive:
    // smart_contracts/voting/contract.algo.ts:126
    // if (this.isPollActive.value === Uint64(1) && Global.latestTimestamp < this.pollEndTime.value) {
    intc_0 // 0
    // smart_contracts/voting/contract.algo.ts:23
    // isPollActive = GlobalState<uint64>({ key: 'active' })
    bytec_2 // "active"
    // smart_contracts/voting/contract.algo.ts:126
    // if (this.isPollActive.value === Uint64(1) && Global.latestTimestamp < this.pollEndTime.value) {
    app_global_get_ex
    assert // check GlobalState exists
    intc_1 // 1
    ==
    bz checkPollActive_after_if_else@4
    global LatestTimestamp
    intc_0 // 0
    // smart_contracts/voting/contract.algo.ts:20
    // pollEndTime = GlobalState<uint64>({ key: 'endTime' })
    bytec_3 // "endTime"
    // smart_contracts/voting/contract.algo.ts:126
    // if (this.isPollActive.value === Uint64(1) && Global.latestTimestamp < this.pollEndTime.value) {
    app_global_get_ex
    assert // check GlobalState exists
    <
    bz checkPollActive_after_if_else@4
    // smart_contracts/voting/contract.algo.ts:127
    // return Uint64(1)
    intc_1 // 1

checkPollActive_after_inlined_smart_contracts/voting/contract.algo.ts::VotingContract.checkPollActive@5:
    // smart_contracts/voting/contract.algo.ts:125
    // checkPollActive(): uint64 {
    itob
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

checkPollActive_after_if_else@4:
    // smart_contracts/voting/contract.algo.ts:129
    // return Uint64(0)
    intc_0 // 0
    // smart_contracts/voting/contract.algo.ts:125
    // checkPollActive(): uint64 {
    b checkPollActive_after_inlined_smart_contracts/voting/contract.algo.ts::VotingContract.checkPollActive@5


// smart_contracts/voting/contract.algo.ts::VotingContract.getRemainingTime[routing]() -> void:
getRemainingTime:
    // smart_contracts/voting/contract.algo.ts:136
    // if (Global.latestTimestamp >= this.pollEndTime.value) return Uint64(0)
    global LatestTimestamp
    intc_0 // 0
    // smart_contracts/voting/contract.algo.ts:20
    // pollEndTime = GlobalState<uint64>({ key: 'endTime' })
    bytec_3 // "endTime"
    // smart_contracts/voting/contract.algo.ts:136
    // if (Global.latestTimestamp >= this.pollEndTime.value) return Uint64(0)
    app_global_get_ex
    assert // check GlobalState exists
    >=
    bz getRemainingTime_after_if_else@3
    intc_0 // 0

getRemainingTime_after_inlined_smart_contracts/voting/contract.algo.ts::VotingContract.getRemainingTime@4:
    // smart_contracts/voting/contract.algo.ts:135
    // getRemainingTime(): uint64 {
    itob
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

getRemainingTime_after_if_else@3:
    // smart_contracts/voting/contract.algo.ts:137
    // return this.pollEndTime.value - Global.latestTimestamp
    intc_0 // 0
    // smart_contracts/voting/contract.algo.ts:20
    // pollEndTime = GlobalState<uint64>({ key: 'endTime' })
    bytec_3 // "endTime"
    // smart_contracts/voting/contract.algo.ts:137
    // return this.pollEndTime.value - Global.latestTimestamp
    app_global_get_ex
    assert // check GlobalState exists
    global LatestTimestamp
    -
    // smart_contracts/voting/contract.algo.ts:135
    // getRemainingTime(): uint64 {
    b getRemainingTime_after_inlined_smart_contracts/voting/contract.algo.ts::VotingContract.getRemainingTime@4


// smart_contracts/voting/contract.algo.ts::VotingContract.endPoll[routing]() -> void:
endPoll:
    // smart_contracts/voting/contract.algo.ts:144
    // assert(Txn.sender.bytes === this.pollCreator.value, 'Only creator can end poll')
    txn Sender
    intc_0 // 0
    // smart_contracts/voting/contract.algo.ts:21
    // pollCreator = GlobalState<bytes>({ key: 'creator' })
    bytec 12 // "creator"
    // smart_contracts/voting/contract.algo.ts:144
    // assert(Txn.sender.bytes === this.pollCreator.value, 'Only creator can end poll')
    app_global_get_ex
    assert // check GlobalState exists
    ==
    assert // Only creator can end poll
    // smart_contracts/voting/contract.algo.ts:23
    // isPollActive = GlobalState<uint64>({ key: 'active' })
    bytec_2 // "active"
    // smart_contracts/voting/contract.algo.ts:145
    // this.isPollActive.value = Uint64(0)
    intc_0 // 0
    app_global_put
    // smart_contracts/voting/contract.algo.ts:143
    // endPoll(): void {
    intc_1 // 1
    return


// smart_contracts/voting/contract.algo.ts::VotingContract.checkHasVoted[routing]() -> void:
checkHasVoted:
    // smart_contracts/voting/contract.algo.ts:152
    // if (this.hasVoted(Txn.sender).hasValue) {
    txn Sender
    intc_0 // 0
    // smart_contracts/voting/contract.algo.ts:26
    // hasVoted = LocalState<uint64>({ key: 'voted' })
    bytec_0 // "voted"
    // smart_contracts/voting/contract.algo.ts:152
    // if (this.hasVoted(Txn.sender).hasValue) {
    app_local_get_ex
    bury 1
    bz checkHasVoted_after_if_else@3
    // smart_contracts/voting/contract.algo.ts:153
    // return this.hasVoted(Txn.sender).value
    txn Sender
    intc_0 // 0
    // smart_contracts/voting/contract.algo.ts:26
    // hasVoted = LocalState<uint64>({ key: 'voted' })
    bytec_0 // "voted"
    // smart_contracts/voting/contract.algo.ts:153
    // return this.hasVoted(Txn.sender).value
    app_local_get_ex
    assert // check LocalState exists

checkHasVoted_after_inlined_smart_contracts/voting/contract.algo.ts::VotingContract.checkHasVoted@4:
    // smart_contracts/voting/contract.algo.ts:151
    // checkHasVoted(): uint64 {
    itob
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

checkHasVoted_after_if_else@3:
    // smart_contracts/voting/contract.algo.ts:155
    // return Uint64(0)
    intc_0 // 0
    // smart_contracts/voting/contract.algo.ts:151
    // checkHasVoted(): uint64 {
    b checkHasVoted_after_inlined_smart_contracts/voting/contract.algo.ts::VotingContract.checkHasVoted@4


// smart_contracts/voting/contract.algo.ts::VotingContract.getMyVote[routing]() -> void:
getMyVote:
    // smart_contracts/voting/contract.algo.ts:162
    // if (this.hasVoted(Txn.sender).hasValue && this.hasVoted(Txn.sender).value === Uint64(1)) {
    txn Sender
    intc_0 // 0
    // smart_contracts/voting/contract.algo.ts:26
    // hasVoted = LocalState<uint64>({ key: 'voted' })
    bytec_0 // "voted"
    // smart_contracts/voting/contract.algo.ts:162
    // if (this.hasVoted(Txn.sender).hasValue && this.hasVoted(Txn.sender).value === Uint64(1)) {
    app_local_get_ex
    bury 1
    bz getMyVote_after_if_else@4
    txn Sender
    intc_0 // 0
    // smart_contracts/voting/contract.algo.ts:26
    // hasVoted = LocalState<uint64>({ key: 'voted' })
    bytec_0 // "voted"
    // smart_contracts/voting/contract.algo.ts:162
    // if (this.hasVoted(Txn.sender).hasValue && this.hasVoted(Txn.sender).value === Uint64(1)) {
    app_local_get_ex
    assert // check LocalState exists
    intc_1 // 1
    ==
    bz getMyVote_after_if_else@4
    // smart_contracts/voting/contract.algo.ts:163
    // return this.votedOption(Txn.sender).value
    txn Sender
    intc_0 // 0
    // smart_contracts/voting/contract.algo.ts:27
    // votedOption = LocalState<uint64>({ key: 'choice' })
    bytec 13 // "choice"
    // smart_contracts/voting/contract.algo.ts:163
    // return this.votedOption(Txn.sender).value
    app_local_get_ex
    assert // check LocalState exists

getMyVote_after_inlined_smart_contracts/voting/contract.algo.ts::VotingContract.getMyVote@5:
    // smart_contracts/voting/contract.algo.ts:161
    // getMyVote(): uint64 {
    itob
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

getMyVote_after_if_else@4:
    // smart_contracts/voting/contract.algo.ts:165
    // return Uint64(0)
    intc_0 // 0
    // smart_contracts/voting/contract.algo.ts:161
    // getMyVote(): uint64 {
    b getMyVote_after_inlined_smart_contracts/voting/contract.algo.ts::VotingContract.getMyVote@5
